用 Bukkit 的 `EntityDamageByEntityEvent` 作为**唯一**物理近战入口，构造 Mythic 的 `SkillMetadata`，用 `BukkitTriggerMetadata.apply(meta, event)`把**原始伤害事件**绑定进元数据，然后执行你在 `skills.yml` 里配置的规则技能。技能里写 `CancelEvent{forcesync=true}` 即可精准取消这一次玩家物理挥手伤害，不影响 `damage{}` 等技能伤害。`MythicPlayerAttackEvent` 也可监听，但是否能级联取消 Bukkit 原事件取决于内部实现，不如直接绑定 Bukkit 事件稳定。

# 最小实现接口与导包（基于 Mythic 5.x）

**事件与适配**

```java
import org.bukkit.event.EventHandler;
import org.bukkit.event.EventPriority;
import org.bukkit.event.Listener;
import org.bukkit.event.entity.EntityDamageByEntityEvent;
import org.bukkit.event.entity.EntityDamageEvent; // DamageCause
import org.bukkit.entity.Player;
import org.bukkit.entity.LivingEntity;
```

```java
import io.lumine.mythic.bukkit.MythicBukkit;
import io.lumine.mythic.bukkit.adapters.BukkitAdapter;
import io.lumine.mythic.bukkit.adapters.BukkitTriggerMetadata;
```

**技能执行与上下文**

```java
import io.lumine.mythic.api.skills.SkillManager;
import io.lumine.mythic.api.skills.Skill;
import io.lumine.mythic.api.skills.SkillCaster;
import io.lumine.mythic.api.skills.SkillMetadata;
import io.lumine.mythic.api.skills.SkillTrigger;
import io.lumine.mythic.api.adapters.AbstractEntity;
import io.lumine.mythic.api.adapters.AbstractLocation;
```

# 关键 API 对应关系（用于查阅与溯源）

* `MythicBukkit.inst().getSkillManager()` 获取技能管理器与 `SkillCaster` 工厂。([MythicCraft Minecraft Marketplace][1])
* `Skill#execute(...)` 两种重载：可直接传 `SkillTrigger` + 六元参数，或传 `SkillMetadata`。([MythicCraft Minecraft Marketplace][2])
* 事件→元数据绑定：`BukkitTriggerMetadata.apply(SkillMetadata, EntityDamageEvent)`；也有针对弓射击、投射物发射的重载。([MythicCraft Minecraft Marketplace][3])
* 近战物理入口：`EntityDamageByEntityEvent`，近战判定用 `DamageCause.ENTITY_ATTACK`。([hub.spigotmc.org][4])
* Mythic 自带近战事件（可监听）：`io.lumine.mythic.bukkit.events.MythicPlayerAttackEvent`，可取消。([MythicCraft Minecraft Marketplace][5])
* `CancelEvent` 机制要求**同步**执行，否则可能来不及取消。参数 `forcesync=true`。([GitLab][6])

# 参考实现骨架（精简可投产）

> 逻辑：仅在“玩家近战挥手”命中时，同步执行你的 Mythic 规则技能；把 Bukkit 事件塞进 Mythic 元数据，让 `CancelEvent` 能取消它。

```java
public final class MeleeBridgeListener implements Listener {
    private final String RULE_SKILL_NAME = "PlayerMeleeBridgeRules"; // 你在 skills.yml 定义的规则技能

    @EventHandler(priority = EventPriority.HIGHEST, ignoreCancelled = true)
    public void onMelee(final EntityDamageByEntityEvent e) {
        if (!(e.getDamager() instanceof Player player)) return;
        if (!(e.getEntity() instanceof LivingEntity victim)) return;
        if (e.getCause() != EntityDamageEvent.DamageCause.ENTITY_ATTACK) return; // 仅近战物理

        final SkillManager sm = MythicBukkit.inst().getSkillManager();
        final Skill skill = sm.getSkill(RULE_SKILL_NAME).orElse(null);
        if (skill == null) return;

        // 构造执行所需对象
        final SkillCaster caster = sm.getCaster(BukkitAdapter.adapt(player));
        final AbstractEntity trigger = BukkitAdapter.adapt(victim);
        final AbstractLocation origin = BukkitAdapter.adapt(player.getLocation());

        // 方案A：走 SkillMetadata 路线，并把 Bukkit 事件绑定进去（推荐，确保 CancelEvent 直达）
        SkillMetadata meta = /* 按你项目封装：用当前 Mythic 版本的构造/工厂创建 */
            io.lumine.mythic.core.skills.SkillMetadataImpl
                .create(caster, origin, trigger); // 提示：不同小版本签名略有变化，按 IDE/Javadoc 调整

        meta = BukkitTriggerMetadata.apply(meta, e); // 关键：把原始伤害事件塞入元数据

        skill.execute(meta); // 在技能内使用 CancelEvent{forcesync=true}

        // 方案B：不构建 meta，直接带触发器执行（若你更熟悉触发器调用）
        // SkillTrigger ATTACK = SkillTrigger.create("ATTACK"); // 已内置，可直接获取/缓存
        // skill.execute(ATTACK, caster, trigger, origin, new HashSet<>(Set.of(trigger)), new HashSet<>(), 1.0f);
        // 若走方案B，也建议同时使用 BukkitTriggerMetadata.apply 绑定事件，保证 CancelEvent 生效
    }
}
```

> 说明：`SkillMetadataImpl.create(...)` 为示意名，Mythic 5.x 小版本的构造/工厂方法参数次序有差异。你在 IDE 查看 `io.lumine.mythic.core.skills.SkillMetadataImpl` 的可用构造后替换即可；核心点是**先构造 `SkillMetadata`，再用 `BukkitTriggerMetadata.apply(meta, e)` 绑定事件**，最后 `skill.execute(meta)`。接口与绑定方法已在 5.x Javadoc 明确。([MythicCraft Minecraft Marketplace][3])

# skills.yml 示例（确保同步取消）

```yml
PlayerMeleeBridgeRules:
  Skills:
    - cancelEvent{forcesync=true}
    # 你的判定/效果...
    # - state{s=attacked1;loop=ONCE} @self
    # - message{m="blocked"} @trigger
```

`forcesync=true` 是要点，否则事件可能已完成，无法取消。([GitLab][6])

# 何时考虑监听 Mythic 的玩家攻击事件

* 你需要完全复用 Mythic 已做的近战识别边界（冷却、姿态、旁路保护）时，可并行监听 `MythicPlayerAttackEvent` 做统计或前置判定；真正取消仍建议按上面的**Bukkit 事件 + 绑定**路径落地，以避免版本差异带来的级联取消不稳定。([MythicCraft Minecraft Marketplace][5])

# 兼容与风险提示

* **版本漂移**：`SkillMetadataImpl` 构造签名在 5.x 快照间有小改动。建议封装一个 `MetaFactory`，集中适配。
* **区分技能伤害**：仅拦玩家近战 `ENTITY_ATTACK`。Mythic 的 `damage{}` 属于技能系，不走该入口。
* **优先级**：用 `HIGHEST` 且 `ignoreCancelled=true`，保障最晚阶段仍可取消，同时不抢占更早做判定的插件。
* **性能**：只做命中时构造元数据与执行一次技能，风险可控；如有高频 PvP 服，建议加速率限制或缓存 `Skill`/`SkillTrigger`。
